import * as i2 from '@angular/cdk/bidi';
import { BidiModule } from '@angular/cdk/bidi';
import * as i3 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i0 from '@angular/core';
import { EventEmitter, forwardRef, ElementRef, Component, ChangeDetectionStrategy, ViewEncapsulation, Optional, ViewChildren, Input, Output, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import * as i5 from 'ng-zorro-antd/core/outlet';
import { NzOutletModule } from 'ng-zorro-antd/core/outlet';
import { NzI18nModule } from 'ng-zorro-antd/i18n';
import * as i4 from 'ng-zorro-antd/icon';
import { NzIconModule } from 'ng-zorro-antd/icon';
import { __decorate } from 'tslib';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { thumbMotion } from 'ng-zorro-antd/core/animation';
import * as i1 from 'ng-zorro-antd/core/config';
import { WithConfig } from 'ng-zorro-antd/core/config';
import { InputBoolean } from 'ng-zorro-antd/core/util';

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
function normalizeOptions(unnormalized) {
    return unnormalized.map(item => {
        if (typeof item === 'string' || typeof item === 'number') {
            return {
                label: `${item}`,
                value: item
            };
        }
        return item;
    });
}

const NZ_CONFIG_MODULE_NAME = 'segmented';
class NzSegmentedComponent {
    constructor(nzConfigService, cdr, directionality) {
        var _a;
        this.nzConfigService = nzConfigService;
        this.cdr = cdr;
        this.directionality = directionality;
        this._nzModuleName = NZ_CONFIG_MODULE_NAME;
        this.nzBlock = false;
        this.nzDisabled = false;
        this.nzOptions = [];
        this.nzSize = 'default';
        this.nzLabelTemplate = null;
        this.nzValueChange = new EventEmitter();
        this.dir = 'ltr';
        this.selectedIndex = 0;
        this.transitionedToIndex = -1;
        this.animationState = null;
        this.normalizedOptions = [];
        this.destroy$ = new Subject();
        this.onChange = () => { };
        this.onTouched = () => { };
        (_a = this.directionality.change) === null || _a === void 0 ? void 0 : _a.pipe(takeUntil(this.destroy$)).subscribe(direction => {
            this.dir = direction;
            this.cdr.detectChanges();
        });
    }
    ngOnChanges(changes) {
        const { nzOptions } = changes;
        if (nzOptions) {
            this.normalizedOptions = normalizeOptions(nzOptions.currentValue);
        }
    }
    handleOptionClick(index) {
        if (this.nzDisabled) {
            return;
        }
        this.changeSelectedIndex(index);
        this.onChange(index);
        this.nzValueChange.emit(index);
    }
    handleThumbAnimationDone(e) {
        if (e.fromState === 'from') {
            this.selectedIndex = this.transitionedToIndex;
            this.transitionedToIndex = -1;
            this.animationState = null;
            this.cdr.detectChanges();
        }
    }
    writeValue(value) {
        if (typeof value === 'number' && value > -1) {
            this.changeSelectedIndex(value);
            this.cdr.markForCheck();
        }
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    changeSelectedIndex(index) {
        if (!this.listOfOptions || this.selectedIndex === -1 || this.selectedIndex === index) {
            return;
        }
        this.animationState = {
            value: 'from',
            params: getThumbAnimationProps(this.listOfOptions.get(this.selectedIndex).nativeElement)
        };
        this.selectedIndex = -1;
        this.cdr.detectChanges();
        this.animationState = {
            value: 'to',
            params: getThumbAnimationProps(this.listOfOptions.get(index).nativeElement)
        };
        this.transitionedToIndex = index;
        this.cdr.detectChanges();
    }
}
NzSegmentedComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.5", ngImport: i0, type: NzSegmentedComponent, deps: [{ token: i1.NzConfigService }, { token: i0.ChangeDetectorRef }, { token: i2.Directionality, optional: true }], target: i0.ɵɵFactoryTarget.Component });
NzSegmentedComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.5", type: NzSegmentedComponent, selector: "nz-segmented", inputs: { nzBlock: "nzBlock", nzDisabled: "nzDisabled", nzOptions: "nzOptions", nzSize: "nzSize", nzLabelTemplate: "nzLabelTemplate" }, outputs: { nzValueChange: "nzValueChange" }, host: { properties: { "class.ant-segmented-disabled": "!!nzDisabled", "class.ant-segmented-rtl": "dir === 'rtl'", "class.ant-segmented-lg": "nzSize === 'large'", "class.ant-segmented-sm": "nzSize === 'small'", "class.ant-segmented-block": "!!nzBlock" }, classAttribute: "ant-segmented" }, providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => NzSegmentedComponent), multi: true }], viewQueries: [{ propertyName: "listOfOptions", predicate: ["itemLabels"], descendants: true, read: ElementRef }], exportAs: ["nzSegmented"], usesOnChanges: true, ngImport: i0, template: `
    <!-- thumb motion div -->
    <div class="ant-segmented-group">
      <div
        *ngIf="animationState"
        [ngClass]="{ 'ant-segmented-thumb': true, 'ant-segmented-thumb-motion': true }"
        [@thumbMotion]="animationState"
        (@thumbMotion.done)="handleThumbAnimationDone($event)"
      ></div>
      <label
        #itemLabels
        *ngFor="let item of normalizedOptions; let i = index"
        [ngClass]="{
          'ant-segmented-item': true,
          'ant-segmented-item-selected': i === selectedIndex,
          'ant-segmented-item-disabled': !!nzDisabled || item.disabled
        }"
      >
        <input class="ant-segmented-item-input" type="radio" [checked]="i === selectedIndex" />
        <div class="ant-segmented-item-label" (click)="!item.disabled && handleOptionClick(i)">
          <ng-container *ngIf="item.icon; else else_template">
            <span class="ant-segmented-item-icon"><span nz-icon [nzType]="item.icon"></span></span>
            <span>
              <ng-container
                *nzStringTemplateOutlet="item.useTemplate && nzLabelTemplate; context: { $implicit: item, index: i }"
              >
                {{ item.label }}
              </ng-container>
            </span>
          </ng-container>
          <ng-template #else_template>
            <ng-container
              *nzStringTemplateOutlet="item.useTemplate && nzLabelTemplate; context: { $implicit: item, index: i }"
            >
              {{ item.label }}
            </ng-container>
          </ng-template>
        </div>
      </label>
    </div>
  `, isInline: true, dependencies: [{ kind: "directive", type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i4.NzIconDirective, selector: "[nz-icon]", inputs: ["nzSpin", "nzRotate", "nzType", "nzTheme", "nzTwotoneColor", "nzIconfont"], exportAs: ["nzIcon"] }, { kind: "directive", type: i5.NzStringTemplateOutletDirective, selector: "[nzStringTemplateOutlet]", inputs: ["nzStringTemplateOutletContext", "nzStringTemplateOutlet"], exportAs: ["nzStringTemplateOutlet"] }], animations: [thumbMotion], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
__decorate([
    InputBoolean()
], NzSegmentedComponent.prototype, "nzBlock", void 0);
__decorate([
    InputBoolean()
], NzSegmentedComponent.prototype, "nzDisabled", void 0);
__decorate([
    WithConfig()
], NzSegmentedComponent.prototype, "nzSize", void 0);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.5", ngImport: i0, type: NzSegmentedComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    selector: 'nz-segmented',
                    exportAs: 'nzSegmented',
                    template: `
    <!-- thumb motion div -->
    <div class="ant-segmented-group">
      <div
        *ngIf="animationState"
        [ngClass]="{ 'ant-segmented-thumb': true, 'ant-segmented-thumb-motion': true }"
        [@thumbMotion]="animationState"
        (@thumbMotion.done)="handleThumbAnimationDone($event)"
      ></div>
      <label
        #itemLabels
        *ngFor="let item of normalizedOptions; let i = index"
        [ngClass]="{
          'ant-segmented-item': true,
          'ant-segmented-item-selected': i === selectedIndex,
          'ant-segmented-item-disabled': !!nzDisabled || item.disabled
        }"
      >
        <input class="ant-segmented-item-input" type="radio" [checked]="i === selectedIndex" />
        <div class="ant-segmented-item-label" (click)="!item.disabled && handleOptionClick(i)">
          <ng-container *ngIf="item.icon; else else_template">
            <span class="ant-segmented-item-icon"><span nz-icon [nzType]="item.icon"></span></span>
            <span>
              <ng-container
                *nzStringTemplateOutlet="item.useTemplate && nzLabelTemplate; context: { $implicit: item, index: i }"
              >
                {{ item.label }}
              </ng-container>
            </span>
          </ng-container>
          <ng-template #else_template>
            <ng-container
              *nzStringTemplateOutlet="item.useTemplate && nzLabelTemplate; context: { $implicit: item, index: i }"
            >
              {{ item.label }}
            </ng-container>
          </ng-template>
        </div>
      </label>
    </div>
  `,
                    host: {
                        class: 'ant-segmented',
                        '[class.ant-segmented-disabled]': '!!nzDisabled',
                        '[class.ant-segmented-rtl]': `dir === 'rtl'`,
                        '[class.ant-segmented-lg]': `nzSize === 'large'`,
                        '[class.ant-segmented-sm]': `nzSize === 'small'`,
                        '[class.ant-segmented-block]': `!!nzBlock`
                    },
                    providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => NzSegmentedComponent), multi: true }],
                    animations: [thumbMotion]
                }]
        }], ctorParameters: function () {
        return [{ type: i1.NzConfigService }, { type: i0.ChangeDetectorRef }, { type: i2.Directionality, decorators: [{
                        type: Optional
                    }] }];
    }, propDecorators: { listOfOptions: [{
                type: ViewChildren,
                args: ['itemLabels', { read: ElementRef }]
            }], nzBlock: [{
                type: Input
            }], nzDisabled: [{
                type: Input
            }], nzOptions: [{
                type: Input
            }], nzSize: [{
                type: Input
            }], nzLabelTemplate: [{
                type: Input
            }], nzValueChange: [{
                type: Output
            }] } });
function getThumbAnimationProps(element) {
    return {
        transform: element.offsetLeft,
        width: element.clientWidth
    };
}

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
class NzSegmentedModule {
}
NzSegmentedModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.5", ngImport: i0, type: NzSegmentedModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NzSegmentedModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.5", ngImport: i0, type: NzSegmentedModule, declarations: [NzSegmentedComponent], imports: [BidiModule, CommonModule, FormsModule, NzI18nModule, NzIconModule, NzOutletModule], exports: [NzSegmentedComponent] });
NzSegmentedModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.5", ngImport: i0, type: NzSegmentedModule, imports: [BidiModule, CommonModule, FormsModule, NzI18nModule, NzIconModule, NzOutletModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.5", ngImport: i0, type: NzSegmentedModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [NzSegmentedComponent],
                    declarations: [NzSegmentedComponent],
                    imports: [BidiModule, CommonModule, FormsModule, NzI18nModule, NzIconModule, NzOutletModule]
                }]
        }] });

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NzSegmentedComponent, NzSegmentedModule, normalizeOptions };
//# sourceMappingURL=ng-zorro-antd-segmented.mjs.map
